using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace wolfPawRandom
{
	public class Randomizer
	{
		private readonly RandomMatrix _rm = null;
		public RandomMatrix Rm { get => _rm; }
		private int _keyLength = 0;
		public int KeyLength { get => _keyLength; }
		private Stopwatch _sw = new Stopwatch();
		private ulong _initialSeed = 0;
		private ulong _original_initial_seed = 0;
		private readonly int _widthMax = 0;
		private readonly int _heightMax = 0;
		private int _iterations = 0;
		private int _currentKey = 0;


		/// <summary>
		/// Handles the randomization of data using a RandomMatrix object
		/// </summary>
		/// <param name="InitialSeed">Initial Seed to use for randomization. If 0 seed will be autogenerated</param>
		public Randomizer(ulong InitialSeed = 0, int KeyLength = 4, int Iterations = 30)
		{
			_sw.Start();

			_rm = new RandomMatrix();

			_heightMax = _rm.getHeight();

			_widthMax = _rm.getWidth();

			regenerateSeed(InitialSeed);

			_keyLength = KeyLength;

			_iterations = Iterations;

#if DEBUG
			("Generation done in: " + _sw.Elapsed.TotalSeconds + "s...").writel(Extensions.col.yellow);
#endif
			
			_sw.Stop();
		}

		/// <summary>
		/// Used to set the length of they key used for calculating random date
		/// <para>i.e: 1357 = 4 length 3317727 = 7... etc</para>
		/// </summary>
		/// <param name="Length">Integer not equal to 0. Negative integers will be absolutized.</param>
		public void setKeyLength(int Length)
		{
			if (Length == 0) { return; }
			Length = Math.Abs(Length);
			_keyLength = Length;
		}

		/// <summary>
		/// Used to set the number of iterations used for calculating random date
		/// </summary>
		/// <param name="Length">Integer not equal to 0. Negative integers will be absolutized.</param>
		public void setKeyIterations(int Iterations)
		{
			if (Iterations == 0) { return; }
			Iterations = Math.Abs(Iterations);
			_iterations = Iterations;
		}

		/// <summary>
		/// Generates new random seed
		/// </summary>
		public void regenerateSeed(ulong InitialSeed = 0)
		{
			_initialSeed = 0;
			while (_initialSeed == 0) { _initialSeed = generateSeed(); }
			("Initial Seed: ".PadRight(20) + _initialSeed).writel(Extensions.col.green);
			"Seed Color Code: ".PadRight(20).cW(); _initialSeed.ColorCode();
			_original_initial_seed = _initialSeed;
		}

		/// <summary>
		/// Generates random initial seed from initialization vectors from the RandomMatrix
		/// </summary>
		/// <returns></returns>
		public ulong generateSeed()
		{
			ulong initialSeed;
			int len = _rm.Collection.randAdditionalTable.Length;
			var v1 = _rm.Collection.randAdditionalTable[new Random().Next(0, len / 3)];
			var v2 = _rm.Collection.randAdditionalTable[new Random().Next(len / 3, len / 3 + len / 3)];
			string tmp = "";
			Regex r = new Regex(@"(\d+)", RegexOptions.Multiline | RegexOptions.IgnoreCase | RegexOptions.ECMAScript);

			foreach (Match m in r.Matches(v1))
			{
				tmp += m.Groups[0].Value;
			}

			foreach (Match m in r.Matches(v2))
			{
				tmp += m.Groups[0].Value;
			}

			if (String.Empty.larger(tmp, ulong.MaxValue.ToString()) == tmp)
			{ tmp = tmp.Substring(0, ulong.MaxValue.ToString().Length - 1); }

			UInt64.TryParse(tmp, out initialSeed);
			return initialSeed;
		}
		
		private void rotateSeed()
		{
			string s = _initialSeed.ToString();
			s = s.Substring(3) + s.Substring(0, 3);
			ulong.TryParse(s, out _initialSeed);

			if(_initialSeed == _original_initial_seed)
			{
				s = s.Substring(1) + s[0];
			}
			ulong.TryParse(s, out _initialSeed);

#if DEBUG
			("Seed rotated".PadRight(20) + _initialSeed).ceWL("Yellow");
#endif
		}

		private string getKey()
		{
			string k = _initialSeed.ToString().Substring(0, _keyLength);
			rotateSeed();
			return k;
		}

		private int INT(Char c)
		{
			return Convert.ToInt32(c.ToString());
		}

		private int rot1(int key)
		{
			string s = key.ToString();
			s = s.Substring(1) + s[0];
			return Convert.ToInt32(s);
		}

		private int rot50p(int key)
		{
			string s = key.ToString();
			int l = s.Length / 2 > 0 ? s.Length / 2 : 1;
			for(int i = 0; i < l; i++)
			{
				s = s.Substring(1) + s[0];
			}
			return Convert.ToInt32(s);
		}
		
		public int randomInt(bool canBeNegative = false)
		{
			int random = 0;

			string k = getKey();
			int[] vals = new int[_keyLength];
			for (int i = 0; i < _keyLength; i++) { vals[i] = (INT(k[i]) + 1); }
			_currentKey = (vals.Sum() * vals.First() * vals.Last() * vals.Length) - 1;
			int cell = getMatrixCell();
			int lastCell = cell;

			random = lastCell + _currentKey;

			for(int i = 0; i < _iterations; i++)
			{
				cell = getMatrixCell();
				random += cell % ((lastCell % 100) + 1);
				if(i % 2 > 0) { random += (i + lastCell % 10); }
				lastCell = cell;
			}
			
			return random;
		}

		private int getMatrixCell()
		{
			//TODO: FIX THIS BECAUSE IT'S CRAP

			_currentKey = rot1(_currentKey) + 1;

			int w = _currentKey % _widthMax;

			_currentKey += _currentKey % 33;

			int h = _currentKey % _heightMax;

#if DEBUG

			$"POS:{w}. column {h}. row ({w} × {h}) => {_rm.Matrix[h][w]}".cWL("darkyellow");

#endif
			
			return _rm.Matrix[h][w];
		}

	}
}
